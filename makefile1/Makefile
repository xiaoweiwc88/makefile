# Make 工程管理工具:帮助我们实现项目的自动编译
# 在C语言中,只有源文件文件才会参与编译.当只有某些文件做了修改，那么就编译整个项目是一种非常不可取做法。我们需要一种方式能帮我们自动判断，哪些文件做了修改哪些需要重新编译，哪些文件需要先编译，哪些文件需要后编译。Makefile就能够帮助我们来完成这个任务。Makefile仅仅是一个文件,里面有很多的规则，来说明如何编译，编译的顺序. Makefile中制定的规则,会由make这个工具来执行.

# 当想要制定makefile文件名时，在执行时，需要使用下面的命令:
# make -f my_mkfile



# Makefile中的规则有很多，一条规则一般由一下几个部分组成:
# 目标: 依赖列表 
# 	命令列表


# 其中第一条规则中的"目标", 将会成为终极目标.我们的最终目的,就是为了生成这个目标的
# 每一个规则中的目标，都可以是一个文件,也可以是一个标签
# 每一个规则中的目标不一定要有依赖
# 每一个规则，不一定非得有命令列表
# 其他的规则之间,没有比如的顺序关系
# 当时间信息不对时，是需要见时间调整正确之后，才能使用make命令的

#Makefile是根据文件的时间信息，来判断是否需要重新编译

#如果想取消某一条命令本身的打印，那么可以在这个命令的前面加上@符号

#变了赋值方式
B := $A    # := 被称为立即展开赋值
C = $A     # = 被称为延迟展开赋值
A = 10

D = 20
D ?= $A    # ?= 被称为条件赋值，但D之前没有赋过值，将A的值付给D；否则保证原值


E = 30

E += $A    # += 被称为追加赋值,将A的值拼接在E之前的后面

all:
	@echo "B = $B"
	@echo "C = $C"
	@echo "D = $D"
	@echo "E = $E"

#特殊变量: $@ $^ $< $$ $* $?

all2: f1 f2 f3
	@echo '$$@ = ' $@    #$@: 当前规则中的目标
	@echo '$$^ = ' $^    #$^: 当前规则中的所有依赖
	@echo '$$< = ' $<    #$<: 当前依赖中的第一个
	@echo '$$$$ = ' $$$$ #$$: 当前执行的进程的进程编号
	@echo "$$$$ = " $$$$ #$$: 当前执行的进程的进程编号

#	@echo '$* = '$@  # 模式规则中的所有%匹配的部分
#	@echo '$? = '$@  # 模式规则中所有比在所在规则中的目标更新的文件组成列表

f1:
	@touch f1

f2:
	@touch f2

f3:
	@touch f3

